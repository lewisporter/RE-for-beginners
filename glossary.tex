\newglossaryentry{tail call}
{
  name=\RU{хвостовая рекурсия}\EN{tail call}\ESph{}\PTBRph{}\PLph{}\ITAph{},
  description={\RU{Это когда компилятор или интерпретатор превращает рекурсию 
  (с которой возможно это проделать, т.е. \IT{хвостовую}) в итерацию для эффективности}
  \EN{It is when the compiler (or interpreter) transforms the recursion (with which it is possible: \IT{tail recursion}) 
  into an iteration for efficiency}\ESph{}\PTBRph{}\PLph{}\ITAph{}: \href{http://go.yurichev.com/17105}{wikipedia}}
}

\newglossaryentry{endianness}
{
  name=endianness,
  description={\RU{Порядок байт}\EN{Byte order}\ESph{}\PTBRph{}\PLph{}\ITAph{}: \myref{sec:endianness}}
}

\newglossaryentry{caller}
{
  name=caller,
  description={\RU{Функция вызывающая другую функцию}\EN{A function calling another}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{callee}
{
  name=callee,
  description={\RU{Вызываемая функция}\EN{A function being called by another}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{debuggee}
{
  name=debuggee,
  description={\RU{Отлаживаемая программа}\EN{A program being debugged}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{leaf function}
{
  name=leaf function,
  description={\RU{Функция не вызывающая больше никаких функций}
  \EN{A function which does not call any other function}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{link register}
{
  name=link register,
  description=(RISC) {\RU{Регистр в котором обычно записан адрес возврата.
  Это позволяет вызывать leaf-функции без использования стека, т.е. быстрее}
  \EN{A register where the return address is usually stored.
  This makes it possible to call leaf functions without using the stack, i.e., faster}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{anti-pattern}
{
  name=anti-pattern,
  description={\RU{Нечто широко известное как плохое решение}
  \EN{Generally considered as bad practice}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{stack pointer}
{
  name=\RU{указатель стека}\EN{stack pointer}\ESph{}\PTBRph{}\PLph{}\ITAph{},
  description={\RU{Регистр указывающий на место в стеке}
  \EN{A register pointing to a place in the stack}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{decrement}
{
  name=\RU{декремент}\EN{decrement}\ESph{}\PTBRph{}\PLph{}\ITAph{},
  description={\RU{Уменьшение на 1}\EN{Decrease by 1}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{increment}
{
  name=\RU{инкремент}\EN{increment}\ESph{}\PTBRph{}\PLph{}\ITAph{},
  description={\RU{Увеличение на 1}\EN{Increase by 1}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{loop unwinding}
{
  name=loop unwinding,
  description={\RU{Это когда вместо организации цикла на $n$ итераций, компилятор генерирует $n$ копий тела
  цикла, для экономии на инструкциях, обеспечивающих сам цикл}
  \EN{It is when a compiler, instead of generating loop code for $n$ iterations, generates just $n$ copies of the
  loop body, in order to get rid of the instructions for loop maintenance}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{register allocator}
{
  name=register allocator,
  description={\RU{Функция компилятора распределяющая локальные переменные по регистрам процессора}
  \EN{The part of the compiler that assigns CPU registers to local variables}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{quotient}
{
  name=\RU{частное}\EN{quotient}\ESph{}\PTBRph{}\PLph{}\ITAph{},
  description={\RU{Результат деления}\EN{Division result}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{product}
{
  name=\RU{произведение}\EN{product}\ESph{}\PTBRph{}\PLph{}\ITAph{},
  description={\RU{Результат умножения}\EN{Multiplication result}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{NOP}
{
  name=NOP,
  description={\q{no operation}, \RU{холостая инструкция}\EN{idle instruction}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{POKE}
{
  name=POKE,
  description={\RU{Инструкция языка BASIC записывающая байт по определенному адресу}
  	\EN{BASIC language instruction for writing a byte at a specific address}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{keygenme}
{
  name=keygenme,
  description={\RU{Программа, имитирующая защиту вымышленной программы, для которой нужно сделать 
  генератор ключей/лицензий}\EN{A program which imitates software protection,
  for which one needs to make a key/license generator}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{dongle}
{
  name=dongle,
  description={\RU{Небольшое устройство подключаемое к LPT-порту для принтера (в прошлом) или к USB}
  \EN{Dongle is a small piece of hardware connected to LPT printer port (in past) or to USB}\ESph{}\PTBRph{}\PLph{}\ITAph{}.
  \RU{Исполняло функции security token-а, имела память и, иногда,
  секретную (крипто-)хеширующую функцию}\EN{Its function was similar to a security token, 
  it has some memory and, sometimes, a secret (crypto-)hashing algorithm}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{thunk function}
{
  name=thunk function,
  description={\RU{Крохотная функция делающая только одно: вызывающая другую функцию}
  \EN{Tiny function with a single role: call another function}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{user mode}
{
  name=user mode,
  description={\RU{Режим CPU с ограниченными возможностями в котором он исполняет прикладное ПО. ср.}
  \EN{A restricted CPU mode in which it all application software code is executed. cf.}\ESph{}\PTBRph{}\PLph{}\ITAph{} \gls{kernel mode}}
}

\newglossaryentry{kernel mode}
{
  name=kernel mode,
  description={\RU{Режим CPU с неограниченными возможностями в котором он исполняет ядро OS и драйвера. ср.}
  \EN{A restrictions-free CPU mode in which the OS kernel and drivers execute. cf.}\ESph{}\PTBRph{}\PLph{}\ITAph{} \gls{user mode}}
}

\newglossaryentry{Windows NT}
{
  name=Windows NT,
  description={Windows NT, 2000, XP, Vista, 7, 8}
}

\newglossaryentry{atomic operation}
{
  name=atomic operation,
  description={
  \q{$\alpha{}\tau{}o\mu{}o\varsigma{}$}
  %\q{atomic}
  \RU{означает \q{неделимый} в греческом языке, так что атомарная операция ---
  это операция которая гарантированно не будет прервана другими тредами}
  \EN{stands for \q{indivisible} in Greek, so an atomic operation is guaranteed not
  to be interrupted by other threads}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

% to be proofreaded (begin)
\newglossaryentry{NaN}
{
  name=NaN,
  description={
  	\RU{не число: специальные случаи чисел с плавающей запятой, 
  	обычно сигнализирующие об ошибках}\EN{not a number: 
  	a special cases for floating point numbers, usually signaling about errors}\ESph{}\PTBRph{}\PLph{}\ITAph{}
  }
}

\newglossaryentry{basic block}
{
  name=basic block,
  description={
  	\RU{группа инструкций, не имеющая инструкций переходов,
	а также не имеющая переходов в середину блока извне.
	В \IDA он выглядит как просто список инструкций без строк-разрывов}\EN{a group of 
	instructions that do not have jump/branch instructions, and also don't have
	jumps inside the block from the outside.
	In \IDA it looks just like as a list of instructions without empty lines}\ESph{}\PTBRph{}\PLph{}\ITAph{}
  }
}

\newglossaryentry{NEON}
{
  name=NEON,
  description={\ac{AKA} \q{Advanced SIMD}\EMDASH\ac{SIMD} \RU{от}\EN{from}\ESph{}\PTBRph{}\PLph{}\ITAph{} ARM}
}

\newglossaryentry{reverse engineering}
{
  name=reverse engineering,
  description={\RU{процесс понимания как устроена некая вещь, иногда, с целью клонирования оной}
  \EN{act of understanding how the thing works, sometimes in order to clone it}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{compiler intrinsic}
{
  name=compiler intrinsic,
  description={\RU{Специфичная для компилятора функция не являющаяся обычной библиотечной функцией.
	Компилятор вместо её вызова генерирует определенный машинный код.
	Нередко, это псевдофункции для определенной инструкции \ac{CPU}. Читайте больше:}
	\EN{A function specific to a compiler which is not an usual library function.
	The compiler generates a specific machine code instead of a call to it.
	Often, it's a pseudofunction for a specific \ac{CPU} instruction. Read more:}\ESph{}\PTBRph{}\PLph{}\ITAph{} (\myref{sec:compiler_intrinsic})}
}

\newglossaryentry{heap}
{
  name=heap,
  description={\RU{(куча) обычно, большой кусок памяти предоставляемый \ac{OS}, так что прикладное ПО может делить его
  как захочет. malloc()/free() работают с кучей}
  \EN{usually, a big chunk of memory provided by the \ac{OS} so that applications can divide it by themselves as they wish.
  malloc()/free() work with the heap}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{name mangling}
{
  name=name mangling,
  description={\RU{применяется как минимум в \Cpp, где компилятору нужно закодировать имя класса,
  метода и типы аргументов в одной
  строке, которая будет внутренним именем функции. читайте также здесь}
  \EN{used at least in \Cpp, where the compiler needs to encode the name of class, method and argument types in one string,
  which will become the internal name of the function. You can read more about it here}\ESph{}\PTBRph{}\PLph{}\ITAph{}: \myref{namemangling}}
}

\newglossaryentry{xoring}
{
  name=xoring,
  description={\RU{нередко применяемое в английском языке, означает применение операции 
  \ac{XOR}}
  \EN{often used in the English language, which implying applying the \ac{XOR} operation}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{security cookie}
{
  name=security cookie,
  description={\RU{Случайное значение, разное при каждом исполнении. Читайте больше об этом тут}
  \EN{A random value, different at each execution. You can read more about it here}\ESph{}\PTBRph{}\PLph{}\ITAph{}: \myref{subsec:BO_protection}}
}

\newglossaryentry{tracer}
{
  name=tracer,
  description={\RU{Моя простейшая утилита для отладки. Читайте больше об этом тут}
  \EN{My own simple debugging tool. You can read more about it here}\ESph{}\PTBRph{}\PLph{}\ITAph{}: \myref{tracer}}
}

\newglossaryentry{GiB}
{
  name=GiB,
  description={\RU{Гибибайт: $2^{30}$ или 1024 мебибайт или 1073741824 байт}
  \EN{Gibibyte: $2^{30}$ or 1024 mebibytes or 1073741824 bytes}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{CP/M}
{
  name=CP/M,
  description={Control Program for Microcomputers: \RU{очень простая дисковая \ac{OS} использовавшаяся перед}
  \EN{a very basic disk \ac{OS} used before}\ESph{}\PTBRph{}\PLph{}\ITAph{} MS-DOS}
}

\newglossaryentry{stack frame}
{
  name=stack frame,
  description={\RU{Часть стека, в которой хранится информация, связанная с текущей функцией: локальные переменные,
  аргументы функции, \ac{RA}, \etc{}.}\EN{A part of the stack that contains information specific to the current function:
  local variables, function arguments, \ac{RA}, \etc{}}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{jump offset}
{
  name=jump offset,
  description={\RU{Часть опкода JMP или Jcc инструкции, просто прибавляется к адресу следующей инструкции,
  и так вычисляется новый \ac{PC}. Может быть отрицательным}\EN{a part of the JMP or Jcc instruction's opcode, 
  to be added to the address
  of the next instruction, and this is how the new \ac{PC} is calculated. May be negative as well}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{integral type}
{
  name=\RU{интегральный тип данных}\EN{integral data type}\ESph{}\PTBRph{}\PLph{}\ITAph{},
  description={\RU{обычные числа, но не вещественные. могут использоваться для передачи булевых типов и перечислений (enumerations)}
  \EN{usual numbers, but not a real ones. may be used for passing variables of boolean data type and enumerations}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{real number}
{
  name=\RU{вещественное число}\EN{real number}\ESph{}\PTBRph{}\PLph{}\ITAph{},
  description={\RU{числа, которые могут иметь точку. в \CCpp это \Tfloat и \Tdouble}
  \EN{numbers which may contain a dot. this is \Tfloat and \Tdouble in \CCpp}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{PDB}
{
  name=PDB,
  description={(Win32) \RU{Файл с отладочной информацией, обычно просто имена функций, 
  но иногда имена аргументов функций и локальных переменных}
  \EN{Debugging information file, usually just function names, but sometimes also function
  arguments and local variables names}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{NTAPI}
{
  name=NTAPI,
  description={\RU{\ac{API} доступное только в линии Windows NT. 
  Большей частью не документировано Microsoft-ом}\EN{\ac{API} available only in the Windows NT line. 
  Largely not documented by Microsoft}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{stdout}
{
  name=stdout,
  description={standard output}
}

\newglossaryentry{word}
{
  name=word,
  description={\EN{data type fitting in \ac{GPR}}\RU{(слово) тип данных помещающийся в \ac{GPR}\ESph{}\PTBRph{}\PLph{}\ITAph{}}. 
  \RU{В компьютерах старше персональных, память часто измерялась не в байтах, 
  а в словах}\EN{In the computers older than PCs, 
  the memory size was often measured in words rather than bytes}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}

\newglossaryentry{arithmetic mean}
{
  name=\RU{среднее арифметическое}\EN{arithmetic mean}\ESph{}\PTBRph{}\PLph{}\ITAph{},
  description={\EN{a sum of all values divided by their count}
  \RU{сумма всех значений, разделенная на их количество}\ESph{}\PTBRph{}\PLph{}\ITAph{}}
}
