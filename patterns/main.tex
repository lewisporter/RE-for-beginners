%FIXME: requires PTBR and ES revision (dbmussi)
\part{\RU{Образцы кода}\EN{Code patterns}\PTBR{Padrões de código}\ES{Patrones de código}}

\RU{\epigraph{Всё познается в сравнении}{Автор неизвестен}}
\EN{\epigraph{Everything is comprehended in comparison}{Author unknown}}
\PTBR{\epigraph{Tudo é relativo}{Autor desconhecido}}
\ES{\epigraph{Todo es relativo}{Autor desconocido}}
% FIXME: english sentence added. (dbmussi) 
% not sure it's correct. (yurichev)
% this is popular Russian proverb and is close to "everything is comprehended in comparison", but the source is lost, however, 
% it's traditionally attributed to all sorts of philosophers..
% I don't know exact analgoue in English language, but OK, let it be so.

\RU{Когда автор этой книги учил Си, а затем \Cpp, он просто писал небольшие фрагменты кода, компилировал и смотрел, что 
получилось на ассемблере. Так было намного проще понять%
\footnote{Честно говоря, он и до сих пор так делаю, когда не понимают, как работает некий код.}.
Он делал это такое количество раз, что связь между кодом на \CCpp и тем, что генерирует компилятор, вбилась в его подсознание достаточно глубоко.
После этого не трудно, глядя на код на ассемблере, сразу в общих чертах понимать, что там было написано на Си. 
Возможно это поможет кому-то ещё.}
\EN{When the author of this book first started learning C and, later, \Cpp, he used to write small pieces of code, compile them, 
and then look at the assembly language output. This made it very easy for him to understand what was going on in the code that he had written.
\footnote{In fact, he still does it when he can't understand what a particular bit of code does.}. 
He did it so many times that the relationship between the \CCpp code and what the compiler produced was imprinted deeply in his mind. 
It's easy to imagine instantly a rough outline of C code's appearance and function. 
Perhaps this technique could be helpful for others.}
\PTBR{Quando o autor deste livro começou a aprender C e, mais tarde, \Cpp, ele costumava escrever pequenos pedaços de código, compilá-los, 
e então olhar a saída em linguagem assembly. Isso tornou muito fácil para ele entender o que estava acontecendo no código que ele tinha escrito.
\footnote{Na verdade, ele ainda faz isso quando não consegue entender o que faz um determinado pedaço de código.}. 
Ele fez isso tantas vezes que o relacionamento entre o código \CCpp code e o que o compilador produzia ficou registrado profundamente em sua mente. 
É fácil imaginar de imediato um esboço da aparência e função do código C. 
Talvez essa técnica poderia ser útil para mais alguém.}
\ES{Cuando el autor de este libro comenzó a aprender C y, más tarde, \Cpp, él solía escribir pequeños trozos de código, compilarlos, 
y luego ver los resultados en lenguaje assembly. Esto lo hizo muy fácil para él entender lo que estaba pasando en el código que había escrito.
\footnote{De hecho, todavia lo hace cuando no puede entender lo que hace una determinada pieza de código.}. 
Él lo hizo tantas veces que la relación entre el código \CCpp y lo que el compilador producido se imprimió profundamente en su mente. 
És fácil imaginar al instante un esbozo de la aparencia y función del código C. 
Quizás esta técnica podría ser útil para otra persona.}

%
%\RU{Здесь много примеров и для x86/x64 и для ARM}\EN{There are a lot of examples for both x86/x64 
%and ARM}.\PTBR{Há uma série de exemplos para ambos x86/x64 e ARM}.\ES{Hay una serie de ejemplos, tanto para x86/x64 y ARM} 
%\RU{Те, кто уже хорошо знаком с одной из архитектур, могут легко пролистывать страницы}
%\EN{Those who already familiar with one of architectures, may freely skim over pages}.
%\PTBR{Aqueles já familiarizados com alguma das arquiteturas, pode ler superficialmente as próximas páginas}.
%\ES{Los que ya están familiarizados con alguna de las arquitecturas, pueden leer superficialmente las páginas siguientes}.

\RU{Иногда здесь используются достаточно древние компиляторы, чтобы получить самый короткий (или простой) фрагмент кода.}%
\EN{Sometimes ancient compilers are used here, in order to get the shortest (or simplest) possible code snippet.}
\PTBR{Em determinadas partes foram usados aqui compiladores muito antigos, para se obter o menor (ou mais simples) snippet possível.}
\ES{En ciertas partes, se han empleado aquí compiladores muy antiguas, con el fin de obtener lo mas corta (o simple) posible snippet.}
\

\ifdefined\IncludeExercises
\section*{\Exercises}

\RU{Когда автор этой книги учил ассемблер, он также часто компилировал короткие функции на Си и затем постепенно 
переписывал их на ассемблер, с целью получить как можно более короткий код.}%
\EN{When the author of this book studied assembly language, he also often compiled small C-functions and then rewrote
them gradually to assembly, trying to make their code as short as possible.}
\PTBR{Quando o autor deste livro estudou a linguagem assembly, ele também frequentemente compilava pequenas funções em C e então as reescrevia gradualmente em assembly, tentando fazer seu código o menor possível.}
\ES{Cuando el autor de este libro estudió la lenguaje assembly, también con frecuencia compilaba pequeñas funciones en C, y reescribia gradualmente en assembly, tratando de hacer el código lo más pequeño posible}
\RU{Наверное, этим не стоит заниматься в наше время на практике (потому что конкурировать с современными
компиляторами в плане эффективности очень трудно), но это очень хороший способ разобраться в ассемблере
лучше.}%
\EN{This probably is not worth doing in real-world scenarios today, 
because it's hard to compete with modern compilers in terms of efficiency. It is, however, a very good way to gain a better understanding of assembly.}
\PTBR{Provavelmente não vale mais à pena fazer isso em cenários reais atualmente, 
porque é difícil competir com os compiladores modernos em termos de eficiência. É, no entanto, uma forma muito boa de obter um melhor entendimento de assembly.}
\ES{Probablemente no vale la pena hacer esto en escenarios reales actualmente, 
porque es dificil competir con los compiladores modernos en términos de eficiencia. Es, sin embargo, una muy buena manera de obtener una mejor compreensión de la assembly}

\RU{Так что вы можете взять любой фрагмент кода на ассемблере в этой книге и постараться сделать его короче.}%
\EN{Feel free, therefore, to take any assembly code from this book and try to make it shorter.}
\PTBR{Sinta-se livre, portanto, para pegar qualquer código assembly deste livro e tentar torná-lo menor.}
\ES{Siéntase libre, por lo tanto, para tomar cualquier código de este libro y tratar de hacerlo más pequeño.}
\RU{Но не забывайте о тестировании своих результатов.}%
\EN{However, don't forget to test what you have written.}
\PTBR{No entanto, não esqueça de testar o que você tiver escrito.}
\ES{Sin embargo, no se olvide de probar lo que has escrito.}
\fi

% rewrote to show that debug\release and optimisations levels are orthogonal concepts.
\section*{\RU{Уровни оптимизации и отладочная информация}\EN{Optimization levels and debug information}\PTBR{Níveis de otimização e informação de depuração}\ES{Níveles de optimización y la información de depuración}}

\RU{Исходный код можно компилировать различными компиляторами с различными уровнями оптимизации.
В типичном компиляторе этих уровней около трёх, где нулевой уровень~--- отключить оптимизацию.
Различают также направления оптимизации кода по размеру и по скорости.}
\EN{Source code can be compiled by different compilers with various optimization levels.
A typical compiler has about three such levels, where level zero means disable optimization.
Optimization can also be targeted towards code size or code speed.}
\PTBR{O código-fonte pode ser compilado por diferentes compiladores com vários níveis de otimização.
Um compilador típico tem cerca de três destes níveis, onde o nível zero significa desativar a otimização.
A otimização também pode ser direcionada para o tamanho do código ou para a velocidade do código.}
\ES{El código fuente puede ser compilado por diferentes compiladores com varios niveles de optimización.
Un compilador típico tiene alredor de tres de esos niveles, donde el nivel cero significa desactivar la optimización.
La optimización también puede dirigirse hacia el tamaño del código o la velocidad de código.}

\RU{Неоптимизирующий компилятор работает быстрее, генерирует более понятный (хотя и более объемный) код.
Оптимизирующий компилятор работает медленнее и старается сгенерировать более быстрый (хотя и не обязательно краткий) код.}
\EN{A non-optimizing compiler is faster and produces more understandable (albeit verbose) code,
whereas an optimizing compiler is slower and tries to produce code that runs faster (but is not necessarily more compact).}
\PTBR{Um compilador sem otimização é mais rápido e produz código mais inteligível (embora maior),
enquanto que um compilador com otimização é mais lento e tenta produzir um código que execute mais rápido (mas não é necessariamente mais compacto).}
\ES{Un compilador sin optimización es más rápido y produce código más inteligible (aunque más grande), 
mientras un compilador con optimización es más lento y trata de producir un código que corre más rápido (pero no necesariamente más compacto).}

\RU{Наряду с уровнями и направлениями оптимизации компилятор может включать в конечный файл отладочную информацию,
производя таким образом код, который легче отлаживать.}
\EN{In addition to optimization levels and direction, a compiler can include in the resulting file some debug information,
thus producing code for easy debugging.}
\PTBR{Além dos níveis e direcionamento da otimização, o compilador pode incluir no arquivo resultante algumas informações de depuração, produzindo assim código para fácil depuração.}
\ES{Además de los niveles y dirección de la otimización, el compilador puede incluir informaciones de depuración en el archivo resultante, produciendo así código para fácil depuración.}

\RU{Одна очень важная черта отладочного кода в том, что он может содержать
связи между каждой строкой в исходном коде и адресом в машинном коде.}
\EN{One of the important features of the ´debug' code is that it might contain links
between each line of the source code and the respective machine code addresses.}
\PTBR{Uma das características importantes do código de ´debug' é que ele pode conter 
ligações entre cada linha do código-fonte e os respectivos endereços de código de máquina.}
\ES{Una de los características importantes del código de ´debug' és que puede contener enlaces entre
cada línea del código fuente y las direcciones de código de máquina respectivos.}
\RU{Оптимизирующие компиляторы обычно генерируют код, где целые строки из исходного кода
могут быть оптимизированы и не присутствовать в итоговом машинном коде.}
\EN{Optimizing compilers, on the other hand, tend to produce output where entire lines of source code
can be optimized away and thus not even be present in the resulting machine code.}
\PTBR{Compiladores com otimização, por outro lado, tendem a produzir uma saída onde linhas inteiras de código-fonte podem ser otimizadas a ponto de serem removidas e portanto não estarem presentes no código de máquina resultante.}
\ES{Compiladores con optimización, por otro lado, tienden a producir una salida donde líneas enteras de código fuente pueden ser optimizados al punto de ser eliminados y por consiguiente no estar presentes en el código de máquina resultante.}

\RU{Практикующий reverse engineer обычно сталкивается с обоими версиями, потому что некоторые разработчики
включают оптимизацию, некоторые другие\EMDASH{}нет. Вот почему мы постараемся поработать с примерами для обоих версий.}
\EN{Reverse engineers can encounter either version, simply because some developers turn on the compiler's optimization flags and others do not. 
Because of this, we'll try to work on examples of both debug and release versions of the code featured in this book, where possible.}
\PTBR{Engenheiros Reversos podem encontrar ambas as versões, simplesmente porque alguns desenvolvedores ativam as flags de otimização do compilador e outros não ativam. 
Por causa disso, nós tentaremos trabalhar em exemplos de ambas as versões de debug e release do código destacado neste livro, onde possível.}
\ES{Ingenieros Inversos pueden encontrar ambas versiones, simplesmente porque alguns desarrolladores activan los flags de optimización del compilador, y otros no activan. 
Debido a esto, vamos a tratar de trabajar con ejemplos de ambas versiones de debug y release del código resaltado en este libro, cuando sea posible.}

\chapter{\RU{Краткое введение в CPU}\EN{A short introduction to the CPU}\PTBR{Uma breve introdução à CPU}\ES{Una breve introducción a la CPU}}

\EN{The}\PTBR{A}\ES{La} \ac{CPU} \RU{это устройство исполняющее все программы}\EN{is the device that executes the machine code a program consists of}\PTBR{é o dispositivo que executa o código de máquina que consiste num programa}\ES{es el dispositivo que ejecuta el código de máquina que constituye un programa}.

\textbf{\RU{Немного терминологии}\EN{A short glossary}\PTBR{Um pequeno glossário}\ES{Un breve glosario}:}

\begin{description}
\item[\RU{Инструкция}\EN{Instruction}\PTBR{Instrução}\ES{Instrucción}]: \RU{примитивная команда}\EN{A primitive}\PTBR{Um primitivo}\ES{Una primitiva}
	\ac{CPU}\RU{.} \EN{command.}\PTBR{comando.}\ES{comando.}
\RU{Простейшие примеры: перемещение между регистрами, работа с памятью, примитивные арифметические операции}%
\EN{The simplest examples include: moving data between registers, working with memory, primitive arithmetic operations}
\PTBR{Os exemplos mais simples incluem: mover dados entre registradores, trabalhar com a memória, operações aritiméticas primitivas}
\ES{Los ejemplos más simples incluyen: mover datos entre registros, trabajar con la memoria, operaciones aritméticas primitivas}.
\RU{Как правило, каждый}\EN{As a rule, each}\PTBR{Como regra geral, cada}\ES{Como regla general, cada} \ac{CPU} \RU{имеет свой набор инструкций}\EN{has its own instruction set architecture}\PTBR{tem seu próprio conjunto de instruções}\ES{tiene su proprio conjunto de instrucciones} 
(\ac{ISA}).

\item[\RU{Машинный код}\EN{Machine code}]: \RU{код понимаемый}\EN{Code that the}\PTBR{Código que a}\ES{Código que la} \ac{CPU}\EN{ directly processes}\PTBR{ processa diretamente}\ES{ procesa directamente}. 
\RU{Каждая инструкция обычно кодируется несколькими байтами}\EN{Each instruction is usually encoded by several bytes}\PTBR{Cada instrução é normalmente codificada em vários bytes}\ES{Cada instrucción generalmente se codifica por vários bytes}.

\item[\RU{Язык ассемблера}\EN{Assembly language}\PTBR{Linguagem assembly}\ES{Lenguaje assembly}]: 
\RU{машинный код плюс некоторые расширения, призванные облегчить труд программиста: макросы, имена, \etc.}
\EN{Mnemonic code and some extensions like macros that are intended to make a programmer's life easier.}
\PTBR{Código mnemônico e algumas extensões como macros que têm a finalidade de facilitar a vida do programamdor.}
\ES{Código mnemónico y algunas extensiones como macros que destinados a hacer la vida del programador más fácil.}

\item[\RU{Регистр CPU}\EN{CPU register}\PTBR{Registradores da CPU}\ES{Registros de la CPU}]: 
\RU{Каждый}\EN{Each}\PTBR{Cada}\ES{Cada} \ac{CPU} \RU{имеет некоторый фиксированный набор регистров общего назначения}\EN{has a fixed set of general purpose registers}\PTBR{tem um conjunto fixo de registradores de propósito geral}\ES{tiene un conjunto fijo de registros de propósito general} (\ac{GPR}).
$\approx 8$ \InENRU x86, $\approx 16$ \InENRU x86-64, $\approx 16$ \InENRU ARM.
\RU{Проще всего понимать регистр как временную переменную без типа}%
\EN{The easiest way to understand a register is to think of it as an untyped temporary variable}
\PTBR{A forma mais fácil de entender um registrador é pensar nele como uma variável temporária não tipada}
\ES{La forma más fácil de entender un registro es pensar en ello como una variable temporal sin tipo}.
\RU{Можно представить, что вы пишете на \ac{PL} высокого уровня и у вас только 8 переменных шириной 32 (или 64) бита}%
\EN{Imagine if you were working with a high-level \ac{PL} and could only use eight 32-bit (or 64-bit) variables}
\PTBR{Imagine que você estivesse trabalhando com uma \ac{PL} de alto nível e pudesse usar apenas oito variáveis de 32-bit (ou de 64-bit)}
\ES{Imagine si estuviera trabajando con una \ac{PL} de alto nivel y sólo podría utilizar ocho variables de 32-bit (o de 64-bit)}.
\RU{Можно сделать очень много используя только их}\EN{Yet a lot can be done using just these}\PTBR{No entanto, muito ainda pode ser feito usando apenas eles}\ES{Sin embargo mucho se puede hacer usando sólo estos}!
\end{description}

\RU{Откуда взялась разница между машинным кодом и \ac{PL} высокого уровня?
Ответ в том, что люди и \ac{CPU}-ы отличаются друг от друга\EMDASH{}}
\EN{One might wonder why there needs to be a difference between machine code and a \ac{PL}.
The answer lies in the fact that humans and \ac{CPU}s are not alike\EMDASH{}}
\PTBR{Alguém poderia perguntar por que é preciso haver diferença entre código de máquina e uma \ac{PL} de alto nível.
A resposta reside no fato de que humanos e \ac{CPU}s não são iguais\EMDASH{}}
\ES{Uno podría perguntarse por qué es necessário que haya diferencia entre el código de la máquina y una lenguaje de programación de alto nivel.
La respuesta está en el hecho de que los seres humanos y CPUs no son iguales\EMDASH{}}
\RU{человеку проще писать на \ac{PL} высокого уровня вроде \CCpp, Java, Python, 
а \ac{CPU} проще работать с абстракциями куда более низкого уровня}%
\EN{it is much easier for humans to use a high-level \ac{PL} like \CCpp, Java, Python, etc., 
but it is easier for a \ac{CPU} to use a much lower level of abstraction.}
\PTBR{É muito mais fácil para os humanos usar uma \ac{PL} de alto nível como \CCpp, Java, Python, etc.,
mas é muito mais fácil para a \ac{CPU} usar um nível de abstração muito menor.}
\ES{És mucho más fácil para los humanos utilizar un \ac{PL} de alto nivel como \CCpp, Java, Python, etc., 
pero és más fácil para una \ac{CPU} utilizar un nivel mucho más bajo de abstración.}
\RU{Возможно, можно было бы придумать \ac{CPU} исполняющий код \ac{PL} высокого уровня, но он был бы значительно сложнее, чем те, что мы имеем сегодня.}
\EN{Perhaps it would be possible to invent a \ac{CPU} that can execute high-level \ac{PL} code, but it would be many times more complex than the \ac{CPU}s we know of today.}
\PTBR{talvez fosse possível inventar uma \ac{CPU} que pudesse executar código feito em \ac{PL} alto nível, mas seria inúmeras vezes mais complexa do que as \ac{CPU}s que conhecemos hoje.}
\ES{Tal vez sería posible inventar una \ac{CPU} que podría ejecutar código de \ac{PL} de alto nivel, pero sería muchas veces más compleja que las \ac{CPU}s que conocemos hoy.}
% A note on the experiments in this area (like the LISP machines http://en.wikipedia.org/wiki/Lisp_machine
% might be useful
\RU{И наоборот, человеку очень неудобно писать на ассемблере из-за его низкоуровневости,
к тому же, крайне трудно обойтись без мелких ошибок.}
\EN{In a similar fashion, it is very inconvenient for humans to write in assembly language,
due to it being so low-level and difficult to write in without making a huge number of annoying mistakes.}
\PTBR{De forma semelhante, é muito inconveninente para os seres humanos escrever em linguagem assembly, 
devido ao fato dela ser tão baixo nível e difícil de escrever sem comenter uma enorme quantidade de erros irritantes.}
\ES{En uma manera similar, es muy incómodo para los seres humanos escribir en lenguaje assembly, 
debido a que es tan bajo nivel y difícil escribir sin hacer una gran cantidade de errores molestos.}
\RU{Программа, переводящая код из \ac{PL} высокого уровня в ассемблер называется \IT{компилятором}%
\footnote{
	\RU{В более старой русскоязычной литературе также часто встречается термин \q{транслятор}.}
	\EN{Old-school Russian literature also use term \q{translator}.}
	\ESph{}
	\PTBRph{}\PLph{}\ITAph{}
}.}
\EN{The program that converts the high-level \ac{PL} code into assembly is called a \IT{compiler}.}
\PTBR{O programa que converte o código de \ac{PL} de alto nível em assembly é chamado \IT{compiler}.}
\ES{El programa que convierte el código de \ac{PL} de alto nivel en assembly se llama \IT{compiler}.}
% TODO1 add about linker: "компоновщик" и "редактор связей" в русскоязычной лит-ре

\ifx\LITE\undefined
\section{\RU{Несколько слов о разнице между \ac{ISA}}\EN{A couple of words about different \ac{ISA}s}\PTBR{Algumas palavras a respeito de diferentes \ac{ISA}s}\ES{Algunas palabras sobre diferentes \ac{ISA}s}}

\RU{x86 всегда был архитектурой с опкодами переменной длины, так что когда пришла 64-битная эра,
расширения x64 не очень сильно повлияли на \ac{ISA}.}
\RU{В x86 до сих пор есть масса инструкций, появившихся в 16-битном 8086 и присутствующих в самых последних
процессорах.}
\EN{The x86 \ac{ISA} has always been one with variable-length opcodes, so when the 64-bit era came, 
the x64 extensions did not impact the \ac{ISA} very significantly. In fact, the x86 \ac{ISA} still contains a lot of instructions that first appeared in 16-bit 8086 CPU, yet are still found in the CPUs of today.}
\PTBR{O \ac{ISA} x86 sempre possuiu opcodes de tamanho variável, então com a chegada da era do 64-bit, 
as extensões x64 não impactaram a \ac{ISA} de forma muito significante. De fato, o \ac{ISA} x86 ainda contém uma série de instrucões que surgiram inicialmente na CPU 8086 16-bit, mas ainda são encontradas nas CPUs de hoje em dia.}
\ES{El \ac{ISA} x86 siempre ha tenido opcodes de tamaño variable, de modo que cuanco llegó la era de 64-bit, 
las extensiones x64 no impactan el \ac{ISA} de manera muy significativa. De hecho, el \ac{ISA} x86 aún contiene una gran cantidade de instrucciones que primero aparecieron en CPU 8086 16-bit, pero aún se encuentran en las CPUs de hoy.}
\PLph{}\ITAph{}\\
\\
\index{ARM!\ARMMode}%
\index{ARM!\ThumbMode}%
\index{ARM!\ThumbTwoMode}%

\RU{ARM это \ac{RISC}-процессор разработанный с учетом опкодов одинаковой длины, что было некоторым преимуществом в прошлом.}
\EN{ARM is a \ac{RISC} \ac{CPU} designed with constant-length opcode in mind, which had some advantages in the past.}
\PTBR{ARM é uma \ac{CPU} \ac{RISC} desenvolvido com a idéia de opcodes com tamanho constante, o que trouxe algumas vantagens no passado.}
\ES{ARM és una \ac{CPU} \ac{RISC} diseñado con la idea de opcodes con tamaño constante, que tenía algunas ventajas en el pasado.}
\RU{Так что в самом начале все инструкции ARM кодировались 4-мя байтами}%
\EN{In the very beginning, all ARM instructions were encoded in 4 bytes}%
\PTBR{Bem no início, todas as instruções ARM foram codificadas em 4 bytes}%
\ES{En el principio, todas las instrucciones ARM fueron codificados en 4 bytes}%
\ifx\LITE\undefined
\footnote{\RU{Кстати,
инструкции фиксированного размера удобны тем, что всегда можно легко узнать адрес 
следующей (или предыдущей) инструкции. Эта особенность будет рассмотрена в секции об операторе 
switch()~(\myref{sec:SwitchARMLot}).}
\EN{By the way, fixed-length instructions are handy because one can calculate the next (or previous) 
instruction address without effort. This feature will be discussed in the switch() operator~(\myref{sec:SwitchARMLot}) section.}
\PTBR{A propósito, instruções de tamanho fixo são úteis porque se pode calcular o endereço da próxima instrução (ou da anterior) sem esforço. Esta característica será discutida na seção do operador switch() ~(\myref{sec:SwitchARMLot}).}
\ES{Dicho sea de paso, las instrucciones de longitud fija son muy útiles porque se puede calcular la dirección de instrucción siguiente (o anterior) sin esfuerzo. Esta característica se discutirá en la sección de el operador switch() ~(\myref{sec:SwitchARMLot}).}
}%
\fi
.
\RU{Это то, что сейчас называется \q{режим ARM}}\EN{This is now referred to as \q{ARM mode}}\PTBR{Este é atualmente referenciado como \q{ARM mode}}\ES{Esto actualmente se conoce como \q{ARM mode}}.

\RU{Потом они подумали, что это не очень экономично}\EN{Then they thought it wasn't as frugal as they first imagined}\PTBR{Então concluiu-se que não era tão econômico quanto se imaginou a princípio.}\ES{Entonces se llegó a la conclusión que no era tan económico como se imaginó al princípio}.
\RU{На самом деле, самые используемые инструкции\footnote{А это MOV/PUSH/CALL/Jcc} процессора на практике могут быть закодированы
c использованием меньшего количества информации.}
\EN{In fact, most used \ac{CPU} instructions\footnote{These are MOV/PUSH/CALL/Jcc} in real world applications can be encoded using less information.}
\PTBR{Na verdade, as instruções de \ac{CPU} mais utilizadas \footnote{São estas MOV/PUSH/CALL/Jcc} em aplicações do mundo real podem ser codificadas usando menos informação.}
\ES{En realidad, la mayoría de las instrucciones de \ac{CPU} utilizados \footnote{Son estos MOV/PUSH/CALL/Jcc} en aplicaciones del mundo real pueden ser codificados utilizando menos información.}
\RU{Так что они добавили другую \ac{ISA} с названием Thumb, где каждая инструкция кодируется всего лишь
2-мя байтами.}
\EN{They therefore added another \ac{ISA}, called Thumb, where each instruction was encoded in just 2 bytes.}
\PTBR{Foi adicionado então outro \ac{ISA}, chamado Thumb, onde cada instrução era codificada em apenas 2 bytes.}
\ES{Por lo tanto añadieron otra \ac{ISA}, llamado Thumb, donde cada instrucción fue codificada en sólo 2 bytes.}
\RU{Теперь это называется \q{режим Thumb}}\EN{This is now referred as \q{Thumb mode}}\PTBR{Este é conhecido como \q{Thumb mode}}\ES{Esto se conoce como \q{Thumb mode}}.
\RU{Но не все инструкции ARM могут быть закодированы в двух байтах, так что набор инструкций Thumb ограниченный.}
\EN{However, not \IT{all} ARM instructions can be encoded in just 2 bytes, so the Thumb instruction set is somewhat limited.}
\PTBR{No entanto, nem \IT{all} instruções ARM podem ser codificadas em apenas 2 bytes, então o conjunto de instruções Thumb é de certa forma limitado.}
\ES{No obstante, no todas las instrucciones ARM pueden ser codificadas en apenas 2 bytes, entonces el conjunto de instrucciones Thumb es algo limitada.}
\RU{Код, скомпилированный для режима ARM и Thumb может сосуществовать в одной программе.}
\EN{It is worth noting that code compiled for ARM mode and Thumb mode may of course coexist within one single program.}
\PTBR{É interessante notar que códigos compilados para os modos ARM e Thumb podem, conforme esperado, coexistir num mesmo programa.}
\ES{Es importante destacar que el código compilado para el modo ARM y para el modo Thumb pueden, por supuesto, coexistir dentro de un solo programa.}

\RU{Затем создатели ARM решили, что Thumb можно расширить: так появился Thumb-2 (в ARMv7).}
\EN{The ARM creators thought Thumb could be extended, giving rise to Thumb-2, which appeared in ARMv7.}
\PTBR{Os criadores do ARM concluíram que o Thumb poderia ser extendido, dando origem ao Thumb-2, que apareceu no ARMv7.}
\ES{Los creadores de ARM concluyeron que se podría extender el Thumb, dando origem al Thumb-2, que apareció en el ARMv7.}
\RU{Thumb-2 это всё ещё двухбайтные инструкции, но некоторые новые инструкции имеют длину 4 байта.}
\EN{Thumb-2 still uses 2-byte instructions, but has some new instructions which have the size of 4 bytes.}
\PTBR{Thumb-2 ainda usa instruções de 2 bytes, mas possui algumas novas instruções com 4 bytes de tamanho.}
\ES{Thumb-2 sigue utilizando instrucciones de 2 bytes, pero tiene algunas nuevas instrucciones que tienen el tamaño de 4 bytes.}
\RU{Распространено заблуждение, что Thumb-2\EMDASH{}это смесь ARM и Thumb. Это не верно. Режим Thumb-2 был дополнен до
более полной поддержки возможностей процессора и теперь может легко конкурировать с режимом ARM.
Основное количество приложений для \idevices скомпилировано для набора инструкций Thumb-2, потому что Xcode
делает так по умолчанию.}
\EN{There is a common misconception that Thumb-2 is a mix of ARM and Thumb. This is incorrect. 
Rather, Thumb-2 was extended to fully support all processor features so it could
compete with ARM mode\EMDASH{}a goal that was clearly achieved, as the majority of applications for \idevices are compiled for the Thumb-2 instruction set (admittedly, largely due to the fact that Xcode does this by default).}
\PTBR{Há um equívoco comum que Thumb-2 é uma mistura de ARM e Thumb. Isso é incorreto.
Em vez disso, Thumb-2 foi extendido para suportar completamente todos os recursos de processador de forma que ele pudesse competir com o modo ARM\EMDASH{}um objetivo que foi claramente alcançado, uma vez que a maioria das aplicações para \idevices são compiladas para o conjunto de instruções do Thumb-2 (admitidamente, principalmente devido ao fato que o Xcode faz isso por padrão).}
\ES{Hay una idea errónea de que Thumb-2 es una mezcla de ARM y Thumb. Esto es incorrecto. 
Más bien, se extendió Thumb-2 para apoyar plenamente todas las características de processador por lo que podría 
competir con el modo ARM\EMDASH{}un objetivo que se logró con claridad, ya que la mayoria de aplicacciones para \idevices son compmilados para el conjunto de instrucciones del Thumb-2 (la verdade es, en gran parte debido al hecho de que Xcode hace esto por defecto).}
\RU{Потом появился 64-битный ARM. Это \ac{ISA} снова с 4-байтными опкодами, без дополнительного режима Thumb.}
\EN{Later the 64-bit ARM came out. This \ac{ISA} has 4-byte opcodes, and lacked the need of any additional Thumb mode.}
\PTBR{Posteriormente o ARM 64-bit foi lançado. Este \ac{ISA} tem opcodes de 4 bytes, e descarta a necessidade de qualquer modo Thumb adicional.}
\ES{Más tarde, el ARM 64-bit salió. Este \ac{ISA} tiene opcodes de 4 bytes, y descarta la necesidade de cualquier modo Thumb adicional.}
\RU{Но 64-битные требования повлияли на \ac{ISA}, так что теперь у нас 3 набора инструкций ARM:
режим ARM, режим Thumb (включая Thumb-2) и ARM64.}
\EN{However, the 64-bit requirements affected the \ac{ISA}, resulting in us now having three ARM instruction sets: ARM mode, Thumb mode (including Thumb-2) and ARM64.}
\PTBR{No entanto, os requisitos de 64-bit afetaram o \ac{ISA}, resultando em termos atualmente três conjuntos de instruções ARM: ARM mode, Thumb mode (incluindo Thumb-2) e ARM64.}
\ES{Pero, los requisitos de 64-bit afectaron la \ac{ISA}, resultando en ahora tenermos tres conjuntos de instrucciones ARM: ARM mode, Thumb mode (incluyendo Thumb-2) y ARM64.}
\RU{Эти наборы инструкций частично пересекаются, но можно сказать, это скорее разные наборы, нежели вариации одного.}%
\EN{These \ac{ISA}s intersect partially, but it can be said that they are different \ac{ISA}s, rather than variations of the same one.}
\PTBR{Estes \ac{ISA}s se intersecionam parcialmente, porém podemos dizer que são \ac{ISA}s diferentes, ao invés de variações do mesmo.}
\ES{Estos \ac{ISA}s se intersectan parcialmente, pero puede ser más bien decir que son \ac{ISA}s diferentes, en lugar de variaciones de lo mismo.}
\RU{Следовательно, в этой книге постараемся добавлять фрагменты кода на всех трех ARM \ac{ISA}.}
\EN{Therefore, we would try to add fragments of code in all three ARM \ac{ISA}s in this book.}
\PTBR{Portanto, gostaríamos de tentar adicionar pedaços de código dos três \ac{ISA}s do ARM neste livro.}
\ES{Por lo tanto, nos gustaría intentar añadir fragmentos de código de los tres \ac{ISA}s del ARM en este libro.}

\index{PowerPC}%
\index{MIPS}%
\index{Alpha AXP}%

\RU{Существует ещё много \ac{RISC} \ac{ISA} с опкодами фиксированной 32-битной длины~--- это как минимум}
\EN{There are, by the way, many other \ac{RISC} \ac{ISA}s with fixed length 32-bit opcodes, such as}
\PTBR{Existem, a propósito, muitos outros \ac{RISC} \ac{ISA}s com opcodes de tamanho fixo de 32-bit, como}
\ES{Hay, por cierto, muchos otros \ac{RISC} \ac{ISA}s con opcodes de tamaño fijo de 32-bit, tales como}
MIPS, PowerPC \AndENRU Alpha AXP.
\fi

% chapters
\input{patterns/00_ret/main}
\input{patterns/01_helloworld/main}
\input{patterns/015_prolog_epilogue/main}
\input{patterns/02_stack/main}
\input{patterns/03_printf/main}
\input{patterns/04_scanf/main}
\input{patterns/05_passing_arguments/main}
\input{patterns/06_return_results/main}
\ifx\LITE\undefined
\input{patterns/061_pointers/main}
\fi
\input{patterns/065_GOTO/main}
\input{patterns/07_jcc/main}
\input{patterns/08_switch/main}
\input{patterns/09_loops/main}
\input{patterns/10_strings/main}
\input{patterns/11_arith_optimizations/main}
\ifx\LITE\undefined
\input{patterns/12_FPU/main}
\fi
\input{patterns/13_arrays/main}
\input{patterns/14_bitfields/main}
\input{patterns/145_LCG/main}
\input{patterns/15_structs/main}
\ifx\LITE\undefined
\input{patterns/17_unions/main}
\input{patterns/18_pointers_to_functions/main}
\fi
\input{patterns/185_64bit_in_32_env/main}
\ifx\LITE\undefined
\input{patterns/19_SIMD/main}
\fi
\input{patterns/20_x64/main}
\ifx\LITE\undefined
\input{patterns/205_floating_SIMD/main}
\fi
\ifdefined\IncludeARM
\input{patterns/ARM/main}
\fi
\ifdefined\IncludeMIPS
\input{patterns/MIPS/main}
\fi
