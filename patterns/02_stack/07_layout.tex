\section{\RU{Разметка типичного стека}\EN{A typical stack layout}}

\RU{Разметка типичного стека в 32-битной среде
перед исполнением самой первой инструкции функции выглядит так:}
\EN{A typical stack layout in a 32-bit environment at the start of a function, 
before the first instruction execution looks like this:}

\begin{center}
\begin{tabular}{ | l | l | }
\hline
\dots & \dots \\
\hline
ESP-0xC & \RU{локальная переменная}\EN{local variable} \#2, \MarkedInIDAAs{} \TT{var\_8} \\
\hline
ESP-8 & \RU{локальная переменная}\EN{local variable} \#1, \MarkedInIDAAs{} \TT{var\_4} \\
\hline
ESP-4 & \RU{сохраненное значение}\EN{saved value of} \EBP \\
\hline
ESP & \RU{адрес возврата}\EN{return address} \\
\hline
ESP+4 & \argument \#1, \MarkedInIDAAs{} \TT{arg\_0} \\
\hline
ESP+8 & \argument \#2, \MarkedInIDAAs{} \TT{arg\_4} \\
\hline
ESP+0xC & \argument \#3, \MarkedInIDAAs{} \TT{arg\_8} \\
\hline
\dots & \dots \\
\hline
\end{tabular}
\end{center}
% I think this only applies to RISC architectures
% that don't have a POP instruction that only lets you read one value
% (ie. ARM and MIPS).
% In x86, the return address is saved before entering the function,
% and the function does not have the chance to save the frame pointer.
% Also, you should mention that this is how the stack looks like
% right after the function prologue,
% which some readers might think is the first instruction,
% but is needed to save the frame pointer.
